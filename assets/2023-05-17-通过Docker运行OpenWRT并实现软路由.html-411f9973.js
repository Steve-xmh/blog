import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as l,c,a as e,b as n,d as a,f as r,e as o}from"./app-be572551.js";const d={},p=e("p",null,"自己买了一个 Rock Pi 5，想着它的性能如此强劲，宿舍里却还在用着性能比它慢不止一星半点的路由器来承载宿舍的网络。想着让自己的 Pi 通过 Docker 运行 OpenWRT，然后通过虚拟网卡将所有流量都往 OpenWRT 容器中传递来实现软路由，于是便有了本文的记录。",-1),u={href:"https://blog.csdn.net/qq_38251691/article/details/128356619",target:"_blank",rel:"noopener noreferrer"},v=o('<h2 id="步骤大纲" tabindex="-1"><a class="header-anchor" href="#步骤大纲" aria-hidden="true">#</a> 步骤大纲</h2><ol><li>准备 Docker 和 OpenWRT 镜像</li><li>配置 Docker 的虚拟网络（作为软路由中的 Lan 口和 Wan 口）</li><li>启动 OpenWRT 容器并连接虚拟网络</li><li>配置 OpenWRT 中各个网口的行为</li><li>配置宿主机和 OpenWRT 容器之间的网络连接（通过 ip 命令）</li><li>配置宿主机的网口自动设置其启用状态、Mac 地址和混杂模式（依情况可选）</li></ol><h2 id="正式开始" tabindex="-1"><a class="header-anchor" href="#正式开始" aria-hidden="true">#</a> 正式开始</h2><h3 id="零-需要准备的东西" tabindex="-1"><a class="header-anchor" href="#零-需要准备的东西" aria-hidden="true">#</a> 零：需要准备的东西</h3><ul><li>一个能跑的 Linux 机器（此处演示使用的是 Rock Pi 5B，运行的是 Ubuntu 20.04 LTS）</li><li>机器需要具备两个或以上的物理网口，形式可以是板载的，也可以是外置的（USB 网卡均可）</li></ul><p>为了避免操作中途因为网络环境变化导致无法进入 Linux 机器继续操作，推荐使用非网络 SSH 方式连接你的 Linux 机器，可以是直接物理屏幕键盘或者串口通信。</p><p>本文为了方便操作 Docker，将会全程处于 Root 用户下，故将会省略相关的提权代码。如果你的 Linux 系统不允许你直接登录 Root 用户的话，你可能需要在每个 Docker 指令前添加 <code>sudo</code> 以获得 Root 权限运行指令。</p><h3 id="一-准备-openwrt-的根文件系统-rootfs-归档并导入到-docker-中" tabindex="-1"><a class="header-anchor" href="#一-准备-openwrt-的根文件系统-rootfs-归档并导入到-docker-中" aria-hidden="true">#</a> 一：准备 OpenWRT 的根文件系统（Rootfs）归档并导入到 Docker 中</h3>',8),m={href:"https://downloads.openwrt.org/releases/",target:"_blank",rel:"noopener noreferrer"},k=e("code",null,"default-rootfs.tar.gz",-1),b=o(`<p>随后使用 <code>docker image import &lt;default-rootfs.tar.gz&gt; openwrt-rootfs</code> 命令将根文件系统导入到 Docker 中。注意这里后面的 <code>openwrt-rootfs</code>，这个将会是你这个镜像的名称，之后要使用它的时候会用到。</p><p>导入成功后，输入 <code>docker images</code> 查看镜像，看是不是已经正确导入了：</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>root@rock-5b:~# docker images
REPOSITORY          TAG         IMAGE ID       CREATED        SIZE
openwrt-rootfs      latest      8c374f019165   7 weeks ago    10.5MB # 我们导入的镜像
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二-准备-docker-虚拟网络" tabindex="-1"><a class="header-anchor" href="#二-准备-docker-虚拟网络" aria-hidden="true">#</a> 二：准备 Docker 虚拟网络</h3><p>在创建之前，我们先确认一下我们需要基于哪些物理网口创建我们需要的虚拟网络：</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>root@rock-5b:~# ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enP4p65s0: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:e0:4c:03:00:cd brd ff:ff:ff:ff:ff:ff
    inet6 fe80::2b2:c459:68e9:bcbd/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
3: enx6045bdfb0bd2: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 60:45:bd:fb:0b:d2 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::6245:bdff:fefb:bd2/64 scope link
       valid_lft forever preferred_lft forever
# 省略一部分输出...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定位每一个项目的 ID，确认一下各个网口之后的用途，这里我的 <code>enP4p65s0</code> 网口将被用于 LAN 口，而 <code>enx6045bdfb0bd2</code> 将被用于 WAN 口。</p><p>首先创建用于 LAN 口的虚拟网卡，创建前先想好自己需要创建什么范围的子网和网关地址（路由器的访问 IP），我这里则选择最普通的 <code>192.168.1.0/24</code> 作为子网，路由器的 IP 为 <code>192.168.1.1</code>。</p><p>想好之后即可开始输入指令创建网口，留意 <code>--subnet</code>, <code>--gateway</code> 和 <code>-o parent</code> 参数要修改成上文所述的内容，最后一个参数是虚拟网络名称，这里我写了 <code>openwrt-lan</code>：</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>root@rock-5b:~# docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=enP4p65s0 openwrt-lan
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再创建 WAN 口的虚拟网卡，这个除了要指定所属物理网口外不需要额外设置，这里我将其命名为 <code>openwrt-wan</code>：</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>root@rock-5b:~# docker network create -d macvlan -o parent=enx6045bdfb0bd2 openwrt-wan
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来列出当前已有虚拟网络列表以确认我们的虚拟网络是否都成功创建了：</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>root@rock-5b:~# docker network ls
NETWORK ID     NAME          DRIVER    SCOPE
9064ec779a5b   bridge        bridge    local
b69e3d110f3e   host          host      local
515920225be1   none          null      local
6876eb036fea   openwrt-lan   macvlan   local
5313d119f916   openwrt-wan   macvlan   local
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="三-创建-docker-容器" tabindex="-1"><a class="header-anchor" href="#三-创建-docker-容器" aria-hidden="true">#</a> 三：创建 Docker 容器</h3><p>一开始创建容器的时候只能先连接一个虚拟网络，所以我们先连接 LAN 口网络，为后面连接路由器控制台做准备。</p><p>此处我将容器的名称命名为 <code>openwrt-router</code>，并确保自动重启，连接 <code>openwrt-lan</code> 虚拟网络，提高容器 Root 权限。</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>root@rock-5b:~# docker run -d --name openwrt-router --restart always --network openwrt-lan --privileged openwrt-rootfs:latest /sbin/init
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>启动成功后，将电脑和你的 Linux 机器用网线连接，并设置你的网络设置为同一子网下的不同 IP，然后设置其网关为我们最初配置 LAN 口网络的网关地址。</p><p>然后尝试用浏览器访问路由器的控制台（此处即 <code>192.168.1.1</code>），至此大部分流程已经成功了一部分了。</p><p>接下来连接 WAN 口：</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>root@rock-5b:~# docker network connect openwrt-wan openwrt-router
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>连接完成后即可直接在路由器控制台内配置网口行为，也就是将 LAN 口设置静态地址使其符合我们 LAN 口虚拟网络的配置，开启 LAN 口的 DHCP 服务器功能，将 WAN 口协议设置成 DHCP 客户端即可。</p><p>至此你的 LAN 口下属所有设备应该可以访问互联网了。</p><h3 id="四-让宿主机连接到-openwrt-网络" tabindex="-1"><a class="header-anchor" href="#四-让宿主机连接到-openwrt-网络" aria-hidden="true">#</a> 四：让宿主机连接到 OpenWRT 网络</h3><p>由于 Docker 的隔离特性，目前你的容器宿主还是没有和 OpenWRT 相连的，因此需要在宿主机创建隶属于物理网口中用于 LAN 口的虚拟网卡（非 Docker 的虚拟网卡）（此处为 <code>enP4p65s0</code>）并桥接到 OpenWRT 网络方可连接。</p><p>此处我将这个虚拟网卡命名为 <code>openwrtlan</code>，注意和上面的 <code>openwrt-lan</code> 区分。</p><div class="language-console line-numbers-mode" data-ext="console"><pre class="language-console"><code>root@rock-5b:~# nmcli connection add type macvlan dev enP4p65s0 mode bridge ifname openwrtlan autoconnect yes save yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不出意外的话，虚拟网卡就会自己获取到 IP 地址，并且可以访问互联网了。</p><p>至此你便获得了一个性能极高扩展性极强且不用浪费一整个 Linux 机器做路由器的路由器了，畅快享受网络吧！</p><h3 id="五-设置开启自动配置网络设备-依情况可选" tabindex="-1"><a class="header-anchor" href="#五-设置开启自动配置网络设备-依情况可选" aria-hidden="true">#</a> 五：设置开启自动配置网络设备（依情况可选）</h3><p>因为本人的网口是使用的 USB 网卡，所以似乎每次启动都需要手动打开一次 WAN 网口。 而且每次重启机器的时候 LAN 口的 MAC 地址都会变动，导致每次 DHCP 的 IP 地址不固定。因此这里也记录一下以防之后又需要处理这样的情况。</p><p>以 Root 用户下新建一个脚本，这里我将其放在 <code>/root</code> 并命名为 <code>iplinkset.sh</code>。</p><p>依你的情况写入以下内容：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/sh</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev enP4p65s0 up <span class="token comment"># 启动 LAN 网络设备</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev enx6045bdfb0bd2 up <span class="token comment"># 启动 WAN 网络设备</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev enP4p65s0 promisc on <span class="token comment"># 启动 LAN 混杂模式</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev enx6045bdfb0bd2 promisc on <span class="token comment"># 启动 WAN 混杂模式</span>

<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev openwrtlan down <span class="token comment"># 暂时关闭宿主机和 OpenWRT 之间的连接</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev openwrtlan address <span class="token string">&quot;11:22:33:44:55:66&quot;</span> <span class="token comment"># 指定一个固定的 MAC 地址，此处可随意设置</span>
<span class="token function">ip</span> <span class="token function">link</span> <span class="token builtin class-name">set</span> dev openwrtlan up <span class="token comment"># 重新打开</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为脚本文件赋予可执行权限，然后在 <code>/etc/systemd/system</code> 下新建一个服务描述文件，名字不限，只要后缀是 <code>.service</code>，此处我将其命名为 <code>iplinkset.service</code>。</p><p>写入以下内容：</p><div class="language-ini line-numbers-mode" data-ext="ini"><pre class="language-ini"><code><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Unit</span><span class="token punctuation">]</span></span>
<span class="token key attr-name">Description</span><span class="token punctuation">=</span><span class="token value attr-value">Set up network interfaces # 服务简介，内容不限</span>
<span class="token key attr-name">Requires</span><span class="token punctuation">=</span><span class="token value attr-value">network-online.target</span>
<span class="token key attr-name">After</span><span class="token punctuation">=</span><span class="token value attr-value">network-online.target</span>

<span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Service</span><span class="token punctuation">]</span></span>
<span class="token key attr-name">Type</span><span class="token punctuation">=</span><span class="token value attr-value">oneshot</span>
<span class="token key attr-name">RemainAfterExit</span><span class="token punctuation">=</span><span class="token value attr-value">yes</span>
<span class="token key attr-name">ExecStart</span><span class="token punctuation">=</span><span class="token value attr-value">/root/iplinkset.sh # 此处改为你的脚本路径</span>

<span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">Install</span><span class="token punctuation">]</span></span>
<span class="token key attr-name">WantedBy</span><span class="token punctuation">=</span><span class="token value attr-value">multi-user.target</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保存后执行以下内容启用该服务：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>systemctl reload-daemon
systemctl enable iplinkset.service
systemctl start iplinkset.service
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此已完成所有工作，就可以真正享受网络了！</p><h2 id="后记" tabindex="-1"><a class="header-anchor" href="#后记" aria-hidden="true">#</a> 后记</h2><p>其实看过我博客的都知道，在这之前我都是一直在用 GL.iNet 的路由器，随后需求逐渐增大，路由器已经不能很好的满足需求了，所以想过要换掉它。而目前还剩下一个无线网络需要导入过来，所以无线网卡和天线都在路上了，我想加入新网口的方法也是和上述的步骤类似，创建虚拟网口然后和 OpenWRT 连接配置即可。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,44),f={href:"https://blog.csdn.net/qq_38251691/article/details/128356619",target:"_blank",rel:"noopener noreferrer"},h={href:"https://askubuntu.com/questions/1184648/execute-script-after-successful-network-connection",target:"_blank",rel:"noopener noreferrer"},g={href:"https://askubuntu.com/questions/1065871/change-network-mac-address-using-ip-command",target:"_blank",rel:"noopener noreferrer"},_={href:"https://docs.docker.com/network/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://docs.docker.com/engine/reference/commandline/network_create/",target:"_blank",rel:"noopener noreferrer"};function x(R,A){const s=i("ExternalLinkIcon");return l(),c("div",null,[p,e("p",null,[n("本流程基本上参考自 "),e("a",u,[n("双网口主机通过 docker 安装 openwrt 实现软路由功能_docker 软路由_qq_38251691 的博客-CSDN 博客"),a(s)]),n("，在这里非常感谢作者的文章！")]),r(" more "),v,e("p",null,[n("这个还是很好找的，根据自己的宿主机器架构，在 "),e("a",m,[n("OpenWRT 的固件官网"),a(s)]),n("上选择自己的架构的文件夹，然后从中下载形如 "),k,n(" 的根文件系统归档文件到宿主机器里。考虑到我的机器是 ARM64 架构的，所以我选择了 armvirt/x64 的架构。")]),b,e("ul",null,[e("li",null,[e("a",f,[n("双网口主机通过 docker 安装 openwrt 实现软路由功能_docker 软路由_qq_38251691 的博客-CSDN 博客"),a(s)])]),e("li",null,[e("a",h,[n("18.04 - Execute script after successful network connection - Ask Ubuntu"),a(s)])]),e("li",null,[e("a",g,[n('networking - Change network mac address using "ip" command - Ask Ubuntu'),a(s)])]),e("li",null,[e("a",_,[n("Networking overview | Docker Documentation"),a(s)])]),e("li",null,[e("a",w,[n("docker network create | Docker Documentation"),a(s)])])])])}const D=t(d,[["render",x],["__file","2023-05-17-通过Docker运行OpenWRT并实现软路由.html.vue"]]);export{D as default};
